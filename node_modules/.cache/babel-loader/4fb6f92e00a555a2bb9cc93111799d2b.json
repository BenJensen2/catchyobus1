{"ast":null,"code":"'use strict';\n\nvar convertExpression = require('./convert-expression');\n\nmodule.exports = function () {\n  function isValidExpression(expression, min, max) {\n    var options = expression.split(',');\n    var regexValidation = /^\\d+$|^\\*$|^\\*\\/\\d+$/;\n\n    for (var i = 0; i < options.length; i++) {\n      var option = options[i];\n      var optionAsInt = parseInt(options[i], 10);\n\n      if (optionAsInt < min || optionAsInt > max || !regexValidation.test(option)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function isInvalidSecond(expression) {\n    return !isValidExpression(expression, 0, 59);\n  }\n\n  function isInvalidMinute(expression) {\n    return !isValidExpression(expression, 0, 59);\n  }\n\n  function isInvalidHour(expression) {\n    return !isValidExpression(expression, 0, 23);\n  }\n\n  function isInvalidDayOfMonth(expression) {\n    return !isValidExpression(expression, 1, 31);\n  }\n\n  function isInvalidMonth(expression) {\n    return !isValidExpression(expression, 1, 12);\n  }\n\n  function isInvalidWeekDay(expression) {\n    return !isValidExpression(expression, 0, 7);\n  }\n\n  function validateFields(patterns, executablePatterns) {\n    if (isInvalidSecond(executablePatterns[0])) {\n      throw patterns[0] + ' is a invalid expression for second';\n    }\n\n    if (isInvalidMinute(executablePatterns[1])) {\n      throw patterns[1] + ' is a invalid expression for minute';\n    }\n\n    if (isInvalidHour(executablePatterns[2])) {\n      throw patterns[2] + ' is a invalid expression for hour';\n    }\n\n    if (isInvalidDayOfMonth(executablePatterns[3])) {\n      throw patterns[3] + ' is a invalid expression for day of month';\n    }\n\n    if (isInvalidMonth(executablePatterns[4])) {\n      throw patterns[4] + ' is a invalid expression for month';\n    }\n\n    if (isInvalidWeekDay(executablePatterns[5])) {\n      throw patterns[5] + ' is a invalid expression for week day';\n    }\n  }\n\n  function validate(pattern) {\n    if (typeof pattern !== 'string') {\n      throw 'pattern must be a string!';\n    }\n\n    var patterns = pattern.split(' ');\n    var executablePattern = convertExpression(pattern);\n    var executablePatterns = executablePattern.split(' ');\n\n    if (patterns.length === 5) {\n      patterns = ['0'].concat(patterns);\n    }\n\n    validateFields(patterns, executablePatterns);\n  }\n\n  return validate;\n}();","map":{"version":3,"sources":["/Users/montyj/Documents/projects/catchyobus/node_modules/node-cron/src/pattern-validation.js"],"names":["convertExpression","require","module","exports","isValidExpression","expression","min","max","options","split","regexValidation","i","length","option","optionAsInt","parseInt","test","isInvalidSecond","isInvalidMinute","isInvalidHour","isInvalidDayOfMonth","isInvalidMonth","isInvalidWeekDay","validateFields","patterns","executablePatterns","validate","pattern","executablePattern","concat"],"mappings":"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","sourcesContent":["'use strict';\n\nvar convertExpression = require('./convert-expression');\n\n\nmodule.exports = ( () => {\n  function isValidExpression(expression, min, max){\n    var options = expression.split(',');\n    var regexValidation = /^\\d+$|^\\*$|^\\*\\/\\d+$/;\n    for(var i = 0; i < options.length; i++){\n      var option = options[i];\n      var optionAsInt = parseInt(options[i], 10);\n      if(optionAsInt < min || optionAsInt > max || !regexValidation.test(option)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function isInvalidSecond(expression){\n    return !isValidExpression(expression, 0, 59);\n  }\n\n  function isInvalidMinute(expression){\n    return !isValidExpression(expression, 0, 59);\n  }\n\n  function isInvalidHour(expression){\n    return !isValidExpression(expression, 0, 23);\n  }\n\n  function isInvalidDayOfMonth(expression){\n    return !isValidExpression(expression, 1, 31);\n  }\n\n  function isInvalidMonth(expression){\n    return !isValidExpression(expression, 1, 12);\n  }\n\n  function isInvalidWeekDay(expression){\n    return !isValidExpression(expression, 0, 7);\n  }\n\n  function validateFields(patterns, executablePatterns){\n    if (isInvalidSecond(executablePatterns[0])) {\n      throw patterns[0] + ' is a invalid expression for second';\n    }\n\n    if (isInvalidMinute(executablePatterns[1])) {\n      throw patterns[1] + ' is a invalid expression for minute';\n    }\n\n    if (isInvalidHour(executablePatterns[2])) {\n      throw patterns[2] + ' is a invalid expression for hour';\n    }\n\n    if (isInvalidDayOfMonth(executablePatterns[3])) {\n      throw patterns[3] + ' is a invalid expression for day of month';\n    }\n\n    if (isInvalidMonth(executablePatterns[4])) {\n      throw patterns[4] + ' is a invalid expression for month';\n    }\n\n    if (isInvalidWeekDay(executablePatterns[5])) {\n      throw patterns[5] + ' is a invalid expression for week day';\n    }\n  }\n\n  function validate(pattern){\n    if (typeof pattern !== 'string'){\n      throw 'pattern must be a string!';\n    }\n\n    var patterns = pattern.split(' ');\n    var executablePattern = convertExpression(pattern);\n    var executablePatterns = executablePattern.split(' ');\n\n    if(patterns.length === 5){\n      patterns = ['0'].concat(patterns);\n    }\n\n    validateFields(patterns, executablePatterns);\n  }\n\n  return validate;\n})();\n"]},"metadata":{},"sourceType":"script"}